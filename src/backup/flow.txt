import { useCallback, useState, useEffect, useContext } from 'react';
import ReactFlow, { Controls, Background, MiniMap, applyNodeChanges, useReactFlow, addEdge, useEdgesState, ReactFlowProvider, MarkerType, applyEdgeChanges } from 'reactflow';
import 'reactflow/dist/style.css';
import MultiSelectionToolbar from './MultiSelectionToolbar';
import useKeyboardShortcut from 'use-keyboard-shortcut';
import TextUpdaterNode from '../components/TextUpdaterNode';
import "./styles/Flow.css";
import SimpleFloatingEdge from './SimpleFloatingEdge';
import MindMapProvider, { MindMapContext } from '../contexts/MindMapContext';
import { addNode } from './Menu';
const proOptions = { hideAttribution: true };
const nodeTypes = { textUpdater: TextUpdaterNode };

// import { click } from '@testing-library/user-event/dist/click';

const edgeTypes = {
    floating: SimpleFloatingEdge,
};

function Flow() {
    const [nodes, setNodes] = useState([]);
    const [edges, setEdges] = useEdgesState([]);
    const [activeNodes, setActiveNodes] = useState("");
    const [dataImport, setDataImport] = useState({});
    const keys = ['Shift', 'Enter']
    const reactFlowInstance = useReactFlow();


    //! --------------------------------------------------
    //!             HANDLE SHORTCUT KEYBOARD
    //! --------------------------------------------------

    // const handleKeyboardShortcut = keys => {
    //     onAddNode();
    //     console.log("shift + enter")
    // };
    // useKeyboardShortcut(keys, handleKeyboardShortcut)



    // const [keyShift, setKeyShift] = useState("");
    // const [keyEnter, setKeyEnter] = useState("");
    // const handleKeyPress = useCallback((event) => {
    //     console.log(`Key pressed: ${event.key}`);
    //     if (event.key === "Shift") {
    //         setKeyShift(event.key);
    //     }
    //     if (event.key === "Enter") {
    //         setKeyEnter(event.key);
    //     }
    //     console.log("ini adalah", keyShift, keyEnter, event.key)
    //     if (event.key === "Shift") {
    //         console.log("ini adalah")
    //         // onClick();
    //     }
    // }, []);


    //! --------------------------------------------------
    //!                OTHER FUNCT/LOGIC
    //! --------------------------------------------------
    if (nodes.length !== 0) {
        localStorage.setItem("nodes", JSON.stringify(nodes));
    } else if (nodes.length === 0 && localStorage.getItem("nodes") !== null) {
        if (localStorage.getItem("nodes") === null || JSON.parse(localStorage.getItem("nodes")).length === 1) {
            localStorage.removeItem("nodes")
        }
    }

    if (edges.length !== 0) {
        localStorage.setItem("edges", JSON.stringify(edges));
        // console.log(edges);
    } else if (edges.length === 0 && localStorage.getItem("edges") !== null) {
        if (localStorage.getItem("edges") === null || JSON.parse(localStorage.getItem("edges")).length === 0) {
            localStorage.removeItem("edges")
        }
    }

    //! --------------------------------------------------
    //!                        MENU
    //! --------------------------------------------------

    const onAddNode = (event) => {
        console.log(setNodes)
        addNode(setNodes, setEdges, reactFlowInstance)
        // if (localStorage.getItem("nodes") !== null) {
        //     setNodes(JSON.parse(localStorage.getItem("nodes")))
        //     // console.log(nodes)
        // }
        // if (localStorage.getItem("edges") !== null) {
        //     setEdges(JSON.parse(localStorage.getItem("edges")))
        // }

        // let id = "1";
        // let newNode = {};
        // // if (nodes.length === 0) {
        // if (localStorage.getItem("nodes") === null) {
        //     newNode = {
        //         id: "1", type: 'textUpdater', position: { x: 300, y: 100 }, data: { value: "" }, style: { backgroundColor: "rgb(223, 249, 255)", border: "1px solid rgb(102, 198, 255)", borderRadius: 24 }
        //     }
        // } else {
        //     // let newId = parseInt(nodes[nodes.length - 1].id) + 1;
        //     let newId = parseInt(JSON.parse(localStorage.getItem("nodes")).length) + 1;
        //     let idActiveNodes = localStorage.getItem("active nodes")
        //     let activeNode = JSON.parse(localStorage.getItem("nodes")).find(obj => obj.id === idActiveNodes);
        //     // console.log(activeNode.position.x)
        //     // console.log(activeNode.position.y)
        //     let positionX = 200;
        //     if (activeNode.position.x < 0) {
        //         positionX = -200;
        //     }
        //     // console.log(newId)
        //     newNode = { id: `${newId}`, type: 'textUpdater', position: { x: activeNode.position.x + positionX, y: activeNode.position.y }, data: { value: "" }, style: { backgroundColor: "rgb(223, 249, 255)", border: "1px solid rgb(102, 198, 255)", borderRadius: 24 } }
        //     id = newId;
        // }
        // reactFlowInstance.addNodes(newNode);
        // setNodes((nds) => nds.concat(newNode));
        // if (JSON.parse(localStorage.getItem("nodes")).length !== 0) {
        //     const newEdges = {
        //         id:
        //             `${id}`,
        //         source: localStorage.getItem("active nodes"),
        //         target: `${id}`,
        //         style: { stroke: 'rgb(0, 162, 255)', strokeWidth: "6" },
        //         type: 'floating',
        //     }
        //     setEdges((eds) => eds.concat(newEdges));
        //     reactFlowInstance.addEdges(newEdges)
        //     // console.log(edges)
        // }
    };

    const onRemoveAllNodes = () => {
        localStorage.removeItem("nodes")
        localStorage.removeItem("edges")
        localStorage.removeItem("active nodes")
        localStorage.removeItem("dataConvert")
        window.location.reload();
    }

    const downloadProject = () => {
        const jsonData = localStorage.getItem('dataConvert');
        const parsedData = JSON.parse(jsonData);
        const blob = new Blob([JSON.stringify(parsedData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'myMindMap.json';
        link.click();
    }

    const openProject = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';
        input.onchange = (event) => {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = (event) => {
                const jsonData = event.target.result;
                const parsedData = JSON.parse(jsonData);
                localStorage.setItem("dataConvert", JSON.stringify(parsedData));
                // console.log("import data", parsedData)
                parseData(parsedData.root, true);
            };
            reader.readAsText(file);
        };
        input.click();
    }

    //! --------------------------------------------------
    //!                   HANDLE CHANGES
    //! --------------------------------------------------

    const nodesChange = (changes) => {
        setNodes(JSON.parse(localStorage.getItem("nodes")))
        setNodes((nds) => applyNodeChanges(changes, nds))
        setActiveNodes(changes[0].id)
        localStorage.setItem("active nodes", changes[0].id)
        localStorage.setItem("nodes", JSON.stringify(nodes))
    }

    const onEdgesChange = (changes) => {
        // console.log(changes);
        setEdges(JSON.parse(localStorage.getItem("edges")))
        setEdges((edg) => applyEdgeChanges(changes, edg))
        localStorage.setItem("edges", JSON.stringify(edges))

    }



    //! --------------------------------------------------
    //!                    CONVERT DATA
    //! --------------------------------------------------
    if (localStorage.getItem("edges") !== null && localStorage.getItem("nodes") !== null) {
        const transformData = () => {
            const nodes = JSON.parse(localStorage.getItem("nodes"));
            const edges = JSON.parse(localStorage.getItem("edges"));
            const rootNodes = nodes.filter((node) => {
                return !edges.some((edge) => edge.target === node.id);
            });

            const getChildren = (node) => {
                const childrenEdges = edges.filter((edge) => edge.source === node.id);
                if (childrenEdges.length > 0) {
                    const children = childrenEdges.map((edge) => {
                        const childNode = nodes.find((node) => node.id === edge.target);
                        const child = { id: childNode.id, edges: [{ id: edge.id, source: node.id, target: childNode.id, style: edge.style, type: edge.type }], ...childNode };
                        const childChildren = getChildren(childNode);
                        if (childChildren.length > 0) {
                            child.children = childChildren;
                        }
                        return child;
                    });
                    return children;
                } else {
                    return [];
                }
            };

            const transformedRootNodes = rootNodes.map((rootNode) => {
                const transformedNode = { id: rootNode.id, edges: [], ...rootNode };
                const children = getChildren(rootNode);
                if (children.length > 0) {
                    transformedNode.children = children;
                    transformedNode.edges = children.flatMap(child => child.edges);

                }
                return transformedNode;
            });

            return { root: transformedRootNodes };
        };

        const dataConvert = JSON.stringify(transformData());
        localStorage.setItem("dataConvert", dataConvert);
    }

    //! --------------------------------------------------
    //!                   UNCONVERT DATA
    //! --------------------------------------------------


    const nodesUnconvert = [];
    const edgesUnconvert = [];
    function parseData(data, openProject) {
        data.forEach(item => {
            nodesUnconvert.push({ id: item.id, data: item.data, dragging: item.dragging, height: item.height, position: item.position, positionAbsolute: item.positionAbsolute, selected: item.selected, style: item.style, type: item.type, width: item.width });
            if (item.edges) {
                item.edges.forEach(edge => {
                    edgesUnconvert.push({
                        id: edge.id,
                        source: edge.source,
                        target: edge.target,
                        type: edge.type,
                        style: edge.style
                    });
                });
            }

            if (item.children) {
                parseData(item.children);
            }
        });


        // console.log("open cuy")
        localStorage.setItem("nodes", JSON.stringify(nodesUnconvert));
        localStorage.setItem("edges", JSON.stringify(edgesUnconvert.filter((item, index, self) => index === self.findIndex((t) => t.id === item.id))));
        // console.log("parse data nodes", nodesUnconvert)
        // console.log("parse data edges", edgesUnconvert.filter((item, index, self) => index === self.findIndex((t) => t.id === item.id)));
        window.location.reload();

    }


    //! --------------------------------------------------
    //!                 SIDE EFFECT
    //! --------------------------------------------------
    useEffect(() => {
        if (localStorage.getItem("nodes") !== null) {
            reactFlowInstance.addNodes(JSON.parse(localStorage.getItem("nodes")));
        }
        if (localStorage.getItem("edges") !== null) {
            reactFlowInstance.addEdges(JSON.parse(localStorage.getItem("edges")));
        }
    }, []);



    useEffect(() => {
        const onKeyDown = (e) => {
            if (e.key === "Control") {
                localStorage.setItem("ctrl", true);
            }
            if (e.shiftKey && e.key === 'Enter') {
                onAddNode();
            } else if (localStorage.getItem("ctrl") === "true" && e.shiftKey) {
                console.log("ctrl + shift ditekan")
            }


        }

        const onKeyUp = (e) => {
            if (e.key === "Control") {
                localStorage.removeItem("ctrl")
            }
        }

        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);

        return () => {
            document.removeEventListener("keydown", onKeyDown);
            document.removeEventListener("keyup", onKeyUp);

        }
    }, [])

    //! --------------------------------------------------
    //!                     RETURN JSX
    //! --------------------------------------------------

    return (
        <div style={{ height: '100vh' }}>
            <div className="flex">
                <button onClick={onAddNode} className="absolute left-6 top-24 bg-white z-50 rounded-lg shadow-md py-2 px-4">
                    add node (shift+enter)
                </button>
                <button onClick={onRemoveAllNodes} className="absolute left-6 top-40  bg-white z-50 rounded-lg shadow-md py-2 px-4">
                    Remove All Nodes
                </button>
                <button onClick={openProject} className="absolute left-6 top-56 bg-white z-50 rounded-lg shadow-md py-2 px-4">
                    Open
                </button>
                <button onClick={downloadProject} className="absolute left-6 top-72 bg-white z-50 rounded-lg shadow-md py-2 px-4">
                    Download
                </button>
            </div>
            <ReactFlow
                proOptions={proOptions}
                // zoomSnap={{ minZoom: 0.5, maxZoom: 2 }}
                nodeTypes={nodeTypes}
                edgeTypes={edgeTypes}
                // onConnect={onConnect}
                defaultNodes={nodes}
                defaultEdges={edges}
                onEdgesChange={onEdgesChange}
                onNodesChange={nodesChange}
                className="intersection-flow"
                fitView
            >
                <Background />
                <Controls />
                <MiniMap nodeStrokeWidth={3} zoomable pannable />
                <MultiSelectionToolbar />
            </ReactFlow>
        </div>
    );
}

export default () => (
    <ReactFlowProvider>
        <Flow />
    </ReactFlowProvider>
);





--------------------------------------------


import { useCallback, useState, useEffect, useContext } from 'react';
import ReactFlow, { Controls, Background, MiniMap, applyNodeChanges, useReactFlow, addEdge, useEdgesState, ReactFlowProvider, MarkerType, applyEdgeChanges } from 'reactflow';
import 'reactflow/dist/style.css';
import MultiSelectionToolbar from './MultiSelectionToolbar';
import useKeyboardShortcut from 'use-keyboard-shortcut';
import TextUpdaterNode from '../components/TextUpdaterNode';
import "./styles/Flow.css";
import SimpleFloatingEdge from './SimpleFloatingEdge';
import MindMapProvider, { MindMapContext } from '../contexts/MindMapContext';
// import { removeAllNodes } from './Menu';
const proOptions = { hideAttribution: true };
const nodeTypes = { textUpdater: TextUpdaterNode };

// import { click } from '@testing-library/user-event/dist/click';

const edgeTypes = {
    floating: SimpleFloatingEdge,
};

function Flow() {
    // const [nodes, setNodes] = useState([]);
    const [edges, setEdges] = useEdgesState([]);
    const [activeNodes, setActiveNodes] = useState("");
    const [dataImport, setDataImport] = useState({});
    const keys = ['Shift', 'Enter']
    const reactFlowInstance = useReactFlow();

    const { addNode, cekData, nodes, effectFlow } = useContext(MindMapContext)

    console.log(1)


    //! --------------------------------------------------
    //!                OTHER FUNCT/LOGIC
    //! --------------------------------------------------
    console.log("nodes out 1", nodes)
    cekData()
    console.log("nodes out 2", nodes)

    //! --------------------------------------------------
    //!                        MENU
    //! --------------------------------------------------

    const onAddNode = (event) => {
        console.log("first node", nodes)
        addNode(reactFlowInstance)
        console.log("nodes flow", nodes)
    };

    const removeAllNodes = () => {
        localStorage.removeItem("nodes");
        localStorage.removeItem("edges");
        localStorage.removeItem("active nodes");
        localStorage.removeItem("dataConvert");
        window.location.reload();
    };

    const downloadProject = () => {
        const jsonData = localStorage.getItem('dataConvert');
        const parsedData = JSON.parse(jsonData);
        const blob = new Blob([JSON.stringify(parsedData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'myMindMap.json';
        link.click();
    }

    const openProject = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';
        input.onchange = (event) => {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = (event) => {
                const jsonData = event.target.result;
                const parsedData = JSON.parse(jsonData);
                localStorage.setItem("dataConvert", JSON.stringify(parsedData));
                // console.log("import data", parsedData)
                parseData(parsedData.root, true);
            };
            reader.readAsText(file);
        };
        input.click();
    }

    //! --------------------------------------------------
    //!                   HANDLE CHANGES
    //! --------------------------------------------------

    const nodesChange = (changes) => {
        // setNodes(JSON.parse(localStorage.getItem("nodes")))
        // setNodes((nds) => applyNodeChanges(changes, nds))
        setActiveNodes(changes[0].id)
        localStorage.setItem("active nodes", changes[0].id)
        localStorage.setItem("nodes", JSON.stringify(nodes))
    }

    const onEdgesChange = (changes) => {
        // console.log(changes);
        setEdges(JSON.parse(localStorage.getItem("edges")))
        setEdges((edg) => applyEdgeChanges(changes, edg))
        localStorage.setItem("edges", JSON.stringify(edges))

    }



    //! --------------------------------------------------
    //!                    CONVERT DATA
    //! --------------------------------------------------
    if (localStorage.getItem("edges") !== null && localStorage.getItem("nodes") !== null) {
        console.log("convert")
        const transformData = () => {
            const nodes = JSON.parse(localStorage.getItem("nodes"));
            const edges = JSON.parse(localStorage.getItem("edges"));
            console.log("convert", nodes, edges)
            const rootNodes = nodes.filter((node) => {
                return !edges.some((edge) => edge.target === node.id);
            });

            const getChildren = (node) => {
                const childrenEdges = edges.filter((edge) => edge.source === node.id);
                if (childrenEdges.length > 0) {
                    const children = childrenEdges.map((edge) => {
                        const childNode = nodes.find((node) => node.id === edge.target);
                        const child = { id: childNode.id, edges: [{ id: edge.id, source: node.id, target: childNode.id, style: edge.style, type: edge.type }], ...childNode };
                        const childChildren = getChildren(childNode);
                        if (childChildren.length > 0) {
                            child.children = childChildren;
                        }
                        console.log("child", child)
                        return child;
                    });
                    console.log("children", children)
                    return children;
                } else {
                    return [];
                }
            };

            const transformedRootNodes = rootNodes.map((rootNode) => {
                const transformedNode = { id: rootNode.id, edges: [], ...rootNode };
                const children = getChildren(rootNode);
                if (children.length > 0) {
                    transformedNode.children = children;
                    transformedNode.edges = children.flatMap(child => child.edges);

                }
                console.log("transformedNode", transformedNode)
                return transformedNode;
            });

            return { root: transformedRootNodes };
        };

        const dataConvert = JSON.stringify(transformData());
        console.log("data convert", dataConvert)
        localStorage.setItem("dataConvert", dataConvert);
    }

    //! --------------------------------------------------
    //!                   UNCONVERT DATA
    //! --------------------------------------------------


    const nodesUnconvert = [];
    const edgesUnconvert = [];
    function parseData(data, openProject) {
        data.forEach(item => {
            nodesUnconvert.push({ id: item.id, data: item.data, dragging: item.dragging, height: item.height, position: item.position, positionAbsolute: item.positionAbsolute, selected: item.selected, style: item.style, type: item.type, width: item.width });
            if (item.edges) {
                item.edges.forEach(edge => {
                    edgesUnconvert.push({
                        id: edge.id,
                        source: edge.source,
                        target: edge.target,
                        type: edge.type,
                        style: edge.style
                    });
                });
            }

            if (item.children) {
                parseData(item.children);
            }
        });

        localStorage.setItem("nodes", JSON.stringify(nodesUnconvert));
        localStorage.setItem("edges", JSON.stringify(edgesUnconvert.filter((item, index, self) => index === self.findIndex((t) => t.id === item.id))));
        window.location.reload();

    }


    //! --------------------------------------------------
    //!                 SIDE EFFECT
    //! --------------------------------------------------
    useEffect(() => {
        console.log("effect", nodes)
        effectFlow(reactFlowInstance)
    }, []);



    useEffect(() => {
        const onKeyDown = (e) => {
            if (e.key === "Control") {
                localStorage.setItem("ctrl", true);
            }
            if (e.shiftKey && e.key === 'Enter') {
                onAddNode();
            } else if (localStorage.getItem("ctrl") === "true" && e.shiftKey) {
                console.log("ctrl + shift ditekan")
            }


        }

        const onKeyUp = (e) => {
            if (e.key === "Control") {
                localStorage.removeItem("ctrl")
            }
        }

        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);

        return () => {
            document.removeEventListener("keydown", onKeyDown);
            document.removeEventListener("keyup", onKeyUp);

        }
    }, [])

    //! --------------------------------------------------
    //!                     RETURN JSX
    //! --------------------------------------------------

    return (
        <div style={{ height: '100vh' }}>
            <div className="flex">
                <button onClick={onAddNode} className="absolute left-6 top-24 bg-white z-50 rounded-lg shadow-md py-2 px-4">
                    add node (shift+enter)
                </button>
                <button onClick={removeAllNodes} className="absolute left-6 top-40  bg-white z-50 rounded-lg shadow-md py-2 px-4">
                    Remove All Nodes
                </button>
                <button onClick={openProject} className="absolute left-6 top-56 bg-white z-50 rounded-lg shadow-md py-2 px-4">
                    Open
                </button>
                <button onClick={downloadProject} className="absolute left-6 top-72 bg-white z-50 rounded-lg shadow-md py-2 px-4">
                    Download
                </button>
            </div>
            <ReactFlow
                proOptions={proOptions}
                // zoomSnap={{ minZoom: 0.5, maxZoom: 2 }}
                nodeTypes={nodeTypes}
                edgeTypes={edgeTypes}
                // onConnect={onConnect}
                defaultNodes={nodes}
                defaultEdges={edges}
                onEdgesChange={onEdgesChange}
                onNodesChange={nodesChange}
                className="intersection-flow"
                fitView
            >
                <Background />
                <Controls />
                <MiniMap nodeStrokeWidth={3} zoomable pannable />
                <MultiSelectionToolbar />
            </ReactFlow>
        </div>
    );
}

export default () => (
    <ReactFlowProvider>
        <Flow />
    </ReactFlowProvider>
);


---------------------------------------------------------------



import React, { useState, createContext, useEffect } from "react";
import ReactFlow, { Controls, Background, MiniMap, applyNodeChanges, useReactFlow, addEdge, useEdgesState, ReactFlowProvider, MarkerType, applyEdgeChanges } from "reactflow";
export const MindMapContext = createContext();

const MindMapProvider = (props) => {
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useEdgesState([]);
  const [activeNodes, setActiveNodes] = useState("");
  const [dataImport, setDataImport] = useState({});

  const addNode = (reactFlowInstance) => {
    if (localStorage.getItem("nodes") !== null) {
      setNodes(JSON.parse(localStorage.getItem("nodes")));
      // console.log(nodes)
    }
    if (localStorage.getItem("edges") !== null) {
      setEdges(JSON.parse(localStorage.getItem("edges")));
    }

    let id = "1";
    let newNode = {};
    // if (nodes.length === 0) {
    if (localStorage.getItem("nodes") === null) {
      newNode = {
        id: "1",
        type: "textUpdater",
        position: { x: 300, y: 100 },
        data: { value: "" },
        style: { backgroundColor: "rgb(223, 249, 255)", border: "1px solid rgb(102, 198, 255)", borderRadius: 24 },
      };
    } else {
      // let newId = parseInt(nodes[nodes.length - 1].id) + 1;
      let newId = parseInt(JSON.parse(localStorage.getItem("nodes")).length) + 1;
      let idActiveNodes = localStorage.getItem("active nodes");
      let activeNode = JSON.parse(localStorage.getItem("nodes")).find((obj) => obj.id === idActiveNodes);
      // console.log(activeNode.position.x)
      // console.log(activeNode.position.y)
      let positionX = 200;
      if (activeNode.position.x < 0) {
        positionX = -200;
      }
      // console.log(newId)
      newNode = {
        id: `${newId}`,
        type: "textUpdater",
        position: { x: activeNode.position.x + positionX, y: activeNode.position.y },
        data: { value: "" },
        style: { backgroundColor: "rgb(223, 249, 255)", border: "1px solid rgb(102, 198, 255)", borderRadius: 24 },
      };
      id = newId;
    }

    reactFlowInstance.addNodes(newNode);
    setNodes((nds) => nds.concat(newNode));
    //   console.log(newNode);
    if (localStorage.getItem("nodes") !== null) {
      const newEdges = {
        id: `${id}`,
        source: localStorage.getItem("active nodes"),
        target: `${id}`,
        style: { stroke: "rgb(0, 162, 255)", strokeWidth: "6" },
        type: "floating",
      };
      setEdges((eds) => eds.concat(newEdges));
      reactFlowInstance.addEdges(newEdges);
    }
  };

  const cekData = () => {
    console.log("cek", nodes);

    if (nodes.length !== 0) {
      localStorage.setItem("nodes", JSON.stringify(nodes));
    } else if (nodes.length === 0 && localStorage.getItem("nodes") !== null) {
      if (localStorage.getItem("nodes") === null || JSON.parse(localStorage.getItem("nodes")).length === 1) {
        localStorage.removeItem("nodes");
      }
    }

    if (edges.length !== 0) {
      localStorage.setItem("edges", JSON.stringify(edges));
      // console.log(edges);
    } else if (edges.length === 0 && localStorage.getItem("edges") !== null) {
      if (localStorage.getItem("edges") === null || JSON.parse(localStorage.getItem("edges")).length === 0) {
        localStorage.removeItem("edges");
      }
    }
  };

  const effectFlow = (reactFlowInstance) => {
    if (localStorage.getItem("nodes") !== null) {
      reactFlowInstance.addNodes(JSON.parse(localStorage.getItem("nodes")));
      console.log("effect nodes", reactFlowInstance.addNodes(JSON.parse(localStorage.getItem("nodes"))));
    }
    if (localStorage.getItem("edges") !== null) {
      reactFlowInstance.addEdges(JSON.parse(localStorage.getItem("edges")));
    }
  };

  return <MindMapContext.Provider value={{ nodes, edges, addNode, cekData, effectFlow }}>{props.children}</MindMapContext.Provider>;
};

export default MindMapProvider;



---------------------------------------------------------------------------------------------------------------------------------------------



import { useCallback, useState, useEffect, useContext } from 'react';
import ReactFlow, { Controls, Background, MiniMap, applyNodeChanges, useReactFlow, addEdge, useEdgesState, ReactFlowProvider, MarkerType, applyEdgeChanges } from 'reactflow';
import 'reactflow/dist/style.css';
import MultiSelectionToolbar from './MultiSelectionToolbar';
import TextUpdaterNode from '../components/TextUpdaterNode';
import "./styles/Flow.css";
import SimpleFloatingEdge from './SimpleFloatingEdge';
// import useKeyboardShortcut from 'use-keyboard-shortcut';
const proOptions = { hideAttribution: true };
const nodeTypes = { textUpdater: TextUpdaterNode };

// import { click } from '@testing-library/user-event/dist/click';

const edgeTypes = {
    floating: SimpleFloatingEdge,
};

function Flow() {
    const [nodes, setNodes] = useState([]);
    const [edges, setEdges] = useEdgesState([]);
    const [activeNodes, setActiveNodes] = useState("");
    const [dataImport, setDataImport] = useState({});
    const keys = ['Shift', 'Enter']
    const reactFlowInstance = useReactFlow();

    console.log(1)
    //! --------------------------------------------------
    //!             HANDLE SHORTCUT KEYBOARD
    //! --------------------------------------------------

    // const handleKeyboardShortcut = keys => {
    //     onAddNode();
    //     console.log("shift + enter")
    // };
    // useKeyboardShortcut(keys, handleKeyboardShortcut)



    // const [keyShift, setKeyShift] = useState("");
    // const [keyEnter, setKeyEnter] = useState("");
    // const handleKeyPress = useCallback((event) => {
    //     console.log(`Key pressed: ${event.key}`);
    //     if (event.key === "Shift") {
    //         setKeyShift(event.key);
    //     }
    //     if (event.key === "Enter") {
    //         setKeyEnter(event.key);
    //     }
    //     console.log("ini adalah", keyShift, keyEnter, event.key)
    //     if (event.key === "Shift") {
    //         console.log("ini adalah")
    //         // onClick();
    //     }
    // }, []);


    //! --------------------------------------------------
    //!                OTHER FUNCT/LOGIC
    //! --------------------------------------------------
    console.log("nodes out 1", nodes)
    //  code ini umtuk mengecek apakah nodes ada isinya. Jika ada. 
    if (nodes.length !== 0) {
        localStorage.setItem("nodes", JSON.stringify(nodes));
    } else if (nodes.length === 0 && localStorage.getItem("nodes") !== null) {
        if (localStorage.getItem("nodes") === null || JSON.parse(localStorage.getItem("nodes")).length === 1) {
            localStorage.removeItem("nodes")
        }
    }

    if (edges.length !== 0) {
        localStorage.setItem("edges", JSON.stringify(edges));
        // console.log(edges);
    } else if (edges.length === 0 && localStorage.getItem("edges") !== null) {
        if (localStorage.getItem("edges") === null || JSON.parse(localStorage.getItem("edges")).length === 0) {
            localStorage.removeItem("edges")
        }
    }
    console.log("nodes out 2", nodes)

    //! --------------------------------------------------
    //!                        MENU
    //! --------------------------------------------------

    const onAddNode = (event) => {
        console.log("first node", nodes)
        if (localStorage.getItem("nodes") !== null) {
            setNodes(JSON.parse(localStorage.getItem("nodes")))
            // console.log(nodes)
        }
        if (localStorage.getItem("edges") !== null) {
            setEdges(JSON.parse(localStorage.getItem("edges")))
        }

        let id = "1";
        let newNode = {};
        // if (nodes.length === 0) {
        if (localStorage.getItem("nodes") === null) {
            newNode = {
                id: "1", type: 'textUpdater', position: { x: 300, y: 100 }, data: { value: "" }, style: { backgroundColor: "rgb(223, 249, 255)", border: "1px solid rgb(102, 198, 255)", borderRadius: 24 }
            }
        } else {
            // let newId = parseInt(nodes[nodes.length - 1].id) + 1;
            let newId = parseInt(JSON.parse(localStorage.getItem("nodes")).length) + 1;
            let idActiveNodes = localStorage.getItem("active nodes")
            let activeNode = JSON.parse(localStorage.getItem("nodes")).find(obj => obj.id === idActiveNodes);
            // console.log(activeNode.position.x)
            // console.log(activeNode.position.y)
            let positionX = 200;
            if (activeNode.position.x < 0) {
                positionX = -200;
            }
            // console.log(newId)
            newNode = { id: `${newId}`, type: 'textUpdater', position: { x: activeNode.position.x + positionX, y: activeNode.position.y }, data: { value: "" }, style: { backgroundColor: "rgb(223, 249, 255)", border: "1px solid rgb(102, 198, 255)", borderRadius: 24 } }
            id = newId;
        }
        reactFlowInstance.addNodes(newNode);
        setNodes((nds) => nds.concat(newNode));
        if (JSON.parse(localStorage.getItem("nodes")).length !== 0) {
            const newEdges = {
                id:
                    `${id}`,
                source: localStorage.getItem("active nodes"),
                target: `${id}`,
                style: { stroke: 'rgb(0, 162, 255)', strokeWidth: "6" },
                type: 'floating',
            }
            setEdges((eds) => eds.concat(newEdges));
            reactFlowInstance.addEdges(newEdges)
            // console.log(edges)
        }

        console.log("nodes flow", nodes)
    };

    const onRemoveAllNodes = () => {
        localStorage.removeItem("nodes")
        localStorage.removeItem("edges")
        localStorage.removeItem("active nodes")
        localStorage.removeItem("dataConvert")
        window.location.reload();
    }

    const downloadProject = () => {
        const jsonData = localStorage.getItem('dataConvert');
        const parsedData = JSON.parse(jsonData);
        const blob = new Blob([JSON.stringify(parsedData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'myMindMap.json';
        link.click();
    }

    const openProject = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';
        input.onchange = (event) => {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = (event) => {
                const jsonData = event.target.result;
                const parsedData = JSON.parse(jsonData);
                localStorage.setItem("dataConvert", JSON.stringify(parsedData));
                // console.log("import data", parsedData)
                parseData(parsedData.root, true);
            };
            reader.readAsText(file);
        };
        input.click();
    }

    //! --------------------------------------------------
    //!                   HANDLE CHANGES
    //! --------------------------------------------------

    const nodesChange = (changes) => {
        setNodes(JSON.parse(localStorage.getItem("nodes")))
        setNodes((nds) => applyNodeChanges(changes, nds))
        setActiveNodes(changes[0].id)
        localStorage.setItem("active nodes", changes[0].id)
        localStorage.setItem("nodes", JSON.stringify(nodes))
    }

    const onEdgesChange = (changes) => {
        // console.log(changes);
        setEdges(JSON.parse(localStorage.getItem("edges")))
        setEdges((edg) => applyEdgeChanges(changes, edg))
        localStorage.setItem("edges", JSON.stringify(edges))

    }



    //! --------------------------------------------------
    //!                    CONVERT DATA
    //! --------------------------------------------------
    if (localStorage.getItem("edges") !== null && localStorage.getItem("nodes") !== null) {
        const transformData = () => {
            const nodes = JSON.parse(localStorage.getItem("nodes"));
            const edges = JSON.parse(localStorage.getItem("edges"));
            const rootNodes = nodes.filter((node) => {
                return !edges.some((edge) => edge.target === node.id);
            });

            const getChildren = (node) => {
                const childrenEdges = edges.filter((edge) => edge.source === node.id);
                if (childrenEdges.length > 0) {
                    const children = childrenEdges.map((edge) => {
                        const childNode = nodes.find((node) => node.id === edge.target);
                        const child = { id: childNode.id, edges: [{ id: edge.id, source: node.id, target: childNode.id, style: edge.style, type: edge.type }], ...childNode };
                        const childChildren = getChildren(childNode);
                        if (childChildren.length > 0) {
                            child.children = childChildren;
                        }
                        return child;
                    });
                    return children;
                } else {
                    return [];
                }
            };

            const transformedRootNodes = rootNodes.map((rootNode) => {
                const transformedNode = { id: rootNode.id, edges: [], ...rootNode };
                const children = getChildren(rootNode);
                if (children.length > 0) {
                    transformedNode.children = children;
                    transformedNode.edges = children.flatMap(child => child.edges);

                }
                return transformedNode;
            });

            return { root: transformedRootNodes };
        };

        const dataConvert = JSON.stringify(transformData());
        console.log("data convert", dataConvert)
        localStorage.setItem("dataConvert", dataConvert);
    }

    //! --------------------------------------------------
    //!                   UNCONVERT DATA
    //! --------------------------------------------------


    const nodesUnconvert = [];
    const edgesUnconvert = [];
    function parseData(data, openProject) {
        data.forEach(item => {
            nodesUnconvert.push({ id: item.id, data: item.data, dragging: item.dragging, height: item.height, position: item.position, positionAbsolute: item.positionAbsolute, selected: item.selected, style: item.style, type: item.type, width: item.width });
            if (item.edges) {
                item.edges.forEach(edge => {
                    edgesUnconvert.push({
                        id: edge.id,
                        source: edge.source,
                        target: edge.target,
                        type: edge.type,
                        style: edge.style
                    });
                });
            }

            if (item.children) {
                parseData(item.children);
            }
        });


        // console.log("open cuy")
        localStorage.setItem("nodes", JSON.stringify(nodesUnconvert));
        localStorage.setItem("edges", JSON.stringify(edgesUnconvert.filter((item, index, self) => index === self.findIndex((t) => t.id === item.id))));
        // console.log("parse data nodes", nodesUnconvert)
        // console.log("parse data edges", edgesUnconvert.filter((item, index, self) => index === self.findIndex((t) => t.id === item.id)));
        window.location.reload();

    }


    //! --------------------------------------------------
    //!                 SIDE EFFECT
    //! --------------------------------------------------
    useEffect(() => {
        console.log("effect")
        if (localStorage.getItem("nodes") !== null) {
            reactFlowInstance.addNodes(JSON.parse(localStorage.getItem("nodes")));
            console.log("effect", nodes)
        }
        if (localStorage.getItem("edges") !== null) {
            reactFlowInstance.addEdges(JSON.parse(localStorage.getItem("edges")));
            console.log("effect", edges)
        }
    }, []);



    useEffect(() => {
        const onKeyDown = (e) => {
            if (e.key === "Control") {
                localStorage.setItem("ctrl", true);
            }
            if (e.shiftKey && e.key === 'Enter') {
                onAddNode();
            } else if (localStorage.getItem("ctrl") === "true" && e.shiftKey) {
                console.log("ctrl + shift ditekan")
            }


        }

        const onKeyUp = (e) => {
            if (e.key === "Control") {
                localStorage.removeItem("ctrl")
            }
        }

        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);

        return () => {
            document.removeEventListener("keydown", onKeyDown);
            document.removeEventListener("keyup", onKeyUp);

        }
    }, [])



    //! --------------------------------------------------
    //!                     RETURN JSX
    //! --------------------------------------------------

    return (
        <div style={{ height: '100vh' }}>
            <div className="flex">
                <button onClick={onAddNode} className="absolute left-6 top-24 bg-white z-50 rounded-lg shadow-md py-2 px-4">
                    add node (shift+enter)
                </button>
                <button onClick={onRemoveAllNodes} className="absolute left-6 top-40  bg-white z-50 rounded-lg shadow-md py-2 px-4">
                    Remove All Nodes
                </button>
                <button onClick={openProject} className="absolute left-6 top-56 bg-white z-50 rounded-lg shadow-md py-2 px-4">
                    Open
                </button>
                <button onClick={downloadProject} className="absolute left-6 top-72 bg-white z-50 rounded-lg shadow-md py-2 px-4">
                    Download
                </button>
            </div>
            <ReactFlow
                proOptions={proOptions}
                // zoomSnap={{ minZoom: 0.5, maxZoom: 2 }}
                nodeTypes={nodeTypes}
                edgeTypes={edgeTypes}
                // onConnect={onConnect}
                defaultNodes={nodes}
                defaultEdges={edges}
                onEdgesChange={onEdgesChange}
                onNodesChange={nodesChange}
                className="intersection-flow"
                fitView
            >
                <Background />
                <Controls />
                <MiniMap nodeStrokeWidth={3} zoomable pannable />
                <MultiSelectionToolbar />
            </ReactFlow>
        </div>
    );
}

export default () => (
    <ReactFlowProvider>
        <Flow />
    </ReactFlowProvider>
);
